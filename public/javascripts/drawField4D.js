// Generated by CoffeeScript 1.8.0
(function() {
  var DIMENSION, INIT_SURVIVAL_RATE, RANK, animateCell, animateField, bc, camera, cell, color, colorAlive, colorDead, color_s, controlPanel, controls, decToHexRGB, decToHue, g, game, geometry, i, j, k, key, l, max, mouse, posx, posy, posz, refreshCellColor, render, renderer, rl, scene, showStatus, stats, sum, theta, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;

  RANK = 4;

  DIMENSION = 8;

  INIT_SURVIVAL_RATE = 0.2;

  this.rule = 'normal4d';

  this.boundary_condition = 'periodic';

  this.scale = 10;

  this.ctrl = false;

  this.rotate_speed = 0.1;

  this.radius = 250;

  stats = new Stats();

  stats.domElement.style.position = 'absolute';

  stats.domElement.style.left = (window.innerWidth - 80).toString() + 'px';

  stats.domElement.style.top = (window.innerHeight - 50).toString() + 'px';

  $('body').append(stats.domElement);

  controlPanel = new dat.GUI();

  controlPanel.add(window, 'rotate_speed', 0, 1).step(0.1);

  controlPanel.add(window, 'radius', 0, 500).step(50);

  controlPanel.add(window, 'ctrl', true, false);

  controlPanel.add(window, 'rule', ['normal2d', 'normal4d']);

  controlPanel.add(window, 'boundary_condition', ['periodic', 'dirichlet']);

  controlPanel.close();

  game = new Lifegame(RANK, DIMENSION, rule, boundary_condition, INIT_SURVIVAL_RATE);

  g = game.present();

  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);

  renderer = new THREE.WebGLRenderer();

  renderer.setSize(window.innerWidth, window.innerHeight);

  renderer.domElement.style.position = 'absolute';

  $('#container').append(renderer.domElement);

  decToHexRGB = function(r, g, b) {
    return (r & 0x0000FF) << 16 | (g & 0x0000FF) << 8 | (b & 0x0000FF);
  };

  decToHue = function(d) {
    var d_fixed, d_smooth, lum_b, lum_g, lum_r;
    d_smooth = Math.cos(4 * Math.PI * d);
    d_fixed = 255 * (-d_smooth / 2 + 0.5);
    if (d === 1.0) {
      lum_r = 255;
      lum_g = 0;
      lum_b = 0;
    } else if (d >= 3.0 / 4.0) {
      lum_r = 255;
      lum_g = d_fixed;
      lum_b = 0;
    } else if (d >= 2.0 / 4.0) {
      lum_r = d_fixed;
      lum_g = 255;
      lum_b = 0;
    } else if (d >= 1.0 / 4.0) {
      lum_r = 0;
      lum_g = 255;
      lum_b = d_fixed;
    } else if (d > 0.05) {
      lum_r = 0;
      lum_g = d_fixed;
      lum_b = 255;
    } else {
      lum_r = 0;
      lum_g = 0;
      lum_b = 0;
    }
    return decToHexRGB(lum_r, lum_g, lum_b);
  };

  colorAlive = 0x22FF22;

  colorDead = 0x222222;

  geometry = new THREE.BoxGeometry(scale, scale, scale);

  max = Math.pow(2, DIMENSION) - 1;

  cell = new Array();

  for (i = _i = 0, _ref = DIMENSION - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
    cell[i] = new Array();
    for (j = _j = 0, _ref1 = DIMENSION - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
      cell[i][j] = new Array();
      for (k = _k = 0, _ref2 = DIMENSION - 1; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
        sum = 0;
        for (l = _l = 0, _ref3 = DIMENSION - 1; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; l = 0 <= _ref3 ? ++_l : --_l) {
          sum += Math.pow(g[i][j][k][l] * 2, l);
        }
        color = sum / max;
        color_s = decToHue(color);
        cell[i][j][k] = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
          color: color_s,
          wireframe: true
        }));
        posx = i * scale * 2 - scale * (DIMENSION - 1);
        posy = j * scale * 2 - scale * (DIMENSION - 1);
        posz = k * scale * 2 - scale * (DIMENSION - 1);
        cell[i][j][k].position.set(posx, posy, posz);
        scene.add(cell[i][j][k]);
      }
    }
  }

  controls = new THREE.OrbitControls(camera, renderer.domElement);

  showStatus = function(s) {
    var aliveCellsNum, allCellsNum;
    aliveCellsNum = game.alive();
    allCellsNum = game.cells();
    return $('#status').html('Genesis: ' + game.genesis().toString() + '<br />Generation: ' + game.generation().toString() + '<br />Alive: ' + aliveCellsNum + ' of ' + allCellsNum + ' (' + (100 * aliveCellsNum / allCellsNum).toFixed(2) + '%)' + '<br />' + (game.isStable() ? 'stable' : 'unstable') + '<br />' + (s || ''));
  };

  animateCell = function(cell) {
    var _m, _ref4, _results;
    _results = [];
    for (i = _m = 0, _ref4 = DIMENSION - 1; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
      _results.push((function() {
        var _n, _ref5, _results1;
        _results1 = [];
        for (j = _n = 0, _ref5 = DIMENSION - 1; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
          _results1.push((function() {
            var _o, _ref6, _results2;
            _results2 = [];
            for (k = _o = 0, _ref6 = DIMENSION - 1; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; k = 0 <= _ref6 ? ++_o : --_o) {
              cell[i][j][k].rotation.x += 0.05 * (i - 3);
              _results2.push(cell[i][j][k].rotation.y += 0.05);
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  theta = 0;

  animateField = function(camera) {
    camera.position.x = radius * Math.sin(THREE.Math.degToRad(theta));
    camera.position.y = radius * Math.sin(THREE.Math.degToRad(theta));
    camera.position.z = radius * Math.cos(THREE.Math.degToRad(theta));
    return camera.lookAt(scene.position);
  };

  refreshCellColor = function(cell) {
    var _m, _ref4, _results;
    g = game.present();
    max = Math.pow(2, DIMENSION) - 1;
    _results = [];
    for (i = _m = 0, _ref4 = DIMENSION - 1; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
      _results.push((function() {
        var _n, _ref5, _results1;
        _results1 = [];
        for (j = _n = 0, _ref5 = DIMENSION - 1; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
          _results1.push((function() {
            var _o, _p, _ref6, _ref7, _results2;
            _results2 = [];
            for (k = _o = 0, _ref6 = DIMENSION - 1; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; k = 0 <= _ref6 ? ++_o : --_o) {
              sum = 0;
              for (l = _p = 0, _ref7 = DIMENSION - 1; 0 <= _ref7 ? _p <= _ref7 : _p >= _ref7; l = 0 <= _ref7 ? ++_p : --_p) {
                sum += Math.pow(g[i][j][k][l] * 2, l);
              }
              color = sum / max;
              color_s = decToHue(color);
              _results2.push(cell[i][j][k].material.color.setHex(color_s));
            }
            return _results2;
          })());
        }
        return _results1;
      })());
    }
    return _results;
  };

  mouse = function() {
    return $(window).mousemove(function(e) {
      var mouseX, mouseY, obj, p, ray, rect;
      rect = e.target.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
      mouseX = (mouseX / window.innerWidth) * 2 - 1;
      mouseY = (mouseY / window.innerHeight) * 2 + 1;
      p = new THREE.Vector3(mouseX, mouseY, 1);
      p.unproject(camera);
      ray = new THREE.Raycaster(camera.position, p.sub(camera.position).normalize());
      obj = ray.intersectObjects(scene.chidren);
      if (obj.length) {
        return showStatus(obj.toString());
      }
    });
  };

  key = function() {
    return $(window).keydown(function(e) {
      switch (e.keyCode) {
        case 67:
          game.step();
          refreshCellColor(cell);
          break;
        case 69:
          game.regenerate();
          refreshCellColor(cell);
          break;
        default:
          return true;
      }
      showStatus();
      return false;
    });
  };

  rl = rule;

  bc = boundary_condition;

  render = function() {
    stats.begin();
    theta += rotate_speed;
    if (ctrl) {
      controls.update();
    } else {
      animateField(camera);
    }
    if (rl !== rule) {
      game.setRule(rule);
    }
    if (bc !== boundary_condition) {
      game.setBoundaryCondition(boundary_condition);
    }
    rl = rule;
    bc = boundary_condition;
    renderer.render(scene, camera);
    stats.end();
    return requestAnimationFrame(render);
  };

  showStatus();

  key();

  render();

}).call(this);
